# this script collects the data generated by the script /scripts/run_neurosim.sh and puts all the results in a csv file

# the files generated by run_neurosim.sh are in the following format:

# test_date,test_time,device_name,device_id
# 19.09.2024,14:46:21,LBE247,ID301XR1000Oct
# groundWGFMU,pulseWGFMU,startVolage1,endVoltage1,startVolage2,endVoltage2,stepSize,riseTime,fallTime,pulseWidth,pulseDelay,VpreCond1,VpreCond2,riseTimePrecond,fallTimePrecon,pulseWidthPreCond,bothSides,repetitions,preConEveryLoop,groundVoltageDuringPulse,measName
# SMU2,WGFMU1,0.0,3.0,0.0,-3.0,0.1,2e-08,2e-08,0.0002,0.001,0.0,0.0,0.0001,0.0001,0.005,1.0,2.0,0.0,0.0,2e-4s-3V-m3V
# VStartPos (V),VEndPos (V),VStartNeg (V),VEndNeg (V),twidth (s),onOffRatio,A_LTP,A_LTD,NL_LTP,NL_LTD,num_LTP,num_LTD,fit_R2_LTP,fit_R2_LTD
# 0.2,3.1,-0.1,-3.0,0.0002,5.626865671642277,0.3836673632619052,-0.34633992096895855,3.02,-3.29,28,28,0.9215433278395021,0.9482283527628094
# NeuroSim output:
# =================
# Config read from file: /scratch/msc24h18/msc_project/results/test11/data/LBE247_ID301XR1000Oct/pulsedAmplitudeSweep_DCIV_20240919144619/pulsedAmplitudeSweep_DCIV[LBE247_ID301XR1000Oct(0)]20240919144621/pulsedAmplitudeSweep_DCIV[LBE247_ID301XR1000Oct(0)]20240919144621/pulsedAmplitudeSweep_DCIV[LBE247_ID301XR1000Oct(0)]20240919144621.json
# Device type: RealDevice
# Total SubArray (synaptic core) area=5.0841e-09 m^2
# Total Neuron (neuron peripheries) area=1.2082e-09 m^2
# Total area=6.2923e-09 m^2
# Leakage power of subArrayIH is : 7.1391e-05 W
# Leakage power of subArrayHO is : 1.6238e-05 W
# Leakage power of NeuronIH is : 1.5533e-05 W
# Leakage power of NeuronHO is : 2.4850e-06 W
# Total leakage power of subArray is : 8.7629e-05 W
# Total leakage power of Neuron is : 1.8018e-05 W
# Accuracy at 1 epochs is : 71.37%
# 	Read latency=3.3358e+00 s
# 	Write latency=7.8425e+01 s
# 	Read energy=3.3452e-06 J
# 	Write energy=1.4416e-05 J
# 	The total weight update = 1.6387e+05
# 	The total pulse number = 3.0064e+05
# 	The total actual conductance update = 9.8302e-07
# 	The total actual pulse number = 1.6893e+05
# 	The total actual conductance update per synapse = 2.3976e-11
# 	The total actual pulse number per synapse = 4.1203e+00
# Accuracy at 2 epochs is : 73.19%
# 	Read latency=6.6716e+00 s
# 	Write latency=1.0243e+02 s
# 	Read energy=6.6942e-06 J
# 	Write energy=2.4516e-05 J
# 	The total weight update = 3.2636e+05
# 	The total pulse number = 3.9385e+05
# 	The total actual conductance update = 1.2866e-06
# 	The total actual pulse number = 2.2047e+05
# 	The total actual conductance update per synapse = 3.1380e-11
# 	The total actual pulse number per synapse = 5.3774e+00
# Accuracy at 3 epochs is ...

import os
import csv
import argparse
import numpy as np

def get_data_from_file(file, d_only=False):
    with open(file, 'r') as f:
        data = f.readlines()

        d = dict()
        
        # dictionaries keep insertion order since python 3.7
        try:
            line = data[1].split(',')
            d['device_name'] = line[2]
            d['device_id'] = line[3].strip()
            d['test_date'] = line[0]
            d['test_time'] = line[1]

            keys = data[2].split(',')
            line = data[3].split(',')
            for key, val in zip(keys, line):
                d[key.strip()] = val.strip()

            keys = data[4].split(',')
            line = data[5].split(',')
            for key, val in zip(keys, line):
                d[key.strip()] = val.strip()
        except:
            print(f"Header missing in file {file}. Output will be incomplete.")

        epoch_num = []
        accuracy = []
        read_latency = []
        write_latency = []
        read_energy = []
        write_energy = []
        weight_update = []
        pulse_number = []
        actual_conductance_update = []
        actual_pulse_number = []
        actual_conductance_update_per_synapse = []
        actual_pulse_number_per_synapse = []
        for line in data:
            if "Accuracy at" in line:
                match = line.strip()
                epoch_num.append(int(match.split(' ')[2]))
                accuracy.append(float(match.split(' ')[-1][:-1]))
            if "Read latency" in line:
                read_latency.append(float(line.split('=')[-1].split(' ')[0]))
            if "Write latency" in line:
                write_latency.append(float(line.split('=')[-1].split(' ')[0]))
            if "Read energy" in line:
                read_energy.append(float(line.split('=')[-1].split(' ')[0]))
            if "Write energy" in line:
                write_energy.append(float(line.split('=')[-1].split(' ')[0]))
            if "The total weight update" in line:
                weight_update.append(float(line.split('=')[-1].split(' ')[0]))
            if "The total pulse number" in line:
                pulse_number.append(float(line.split('=')[-1].split(' ')[0]))
            if "The total actual conductance update" in line and "per synapse" not in line:
                actual_conductance_update.append(float(line.split('=')[-1].split(' ')[0]))
            if "The total actual pulse number" in line and "per synapse" not in line:
                actual_pulse_number.append(float(line.split('=')[-1].split(' ')[0]))
            if "The total actual conductance update per synapse" in line:
                actual_conductance_update_per_synapse.append(float(line.split('=')[-1].split(' ')[0]))
            if "The total actual pulse number per synapse" in line:
                actual_pulse_number_per_synapse.append(float(line.split('=')[-1].split(' ')[0]))

        d['epochs'] = epoch_num[-1] if len(epoch_num) > 0 else None
        d['accuracy'] = accuracy[-1] if len(accuracy) > 0 else None

        d['filename'] = os.path.basename(file)

    if d_only:
        return d
    else:
        return d, epoch_num, accuracy, read_latency, write_latency, read_energy, write_energy, weight_update, pulse_number, actual_conductance_update, actual_pulse_number, actual_conductance_update_per_synapse, actual_pulse_number_per_synapse


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("input", type=str, help="Path to the directory containing _output.dat files")
    parser.add_argument("output", type=str, help="Path to the output file")

    args = parser.parse_args()

    files = os.listdir(args.input)
    files = [f for f in files if f.endswith('.dat')]
    data = dict()
    for f in files:
        tmp = get_data_from_file(os.path.join(args.input, f), d_only=True)
        if not data:
            data = {key: [value] for key, value in tmp.items()}
        else:
            for key, value in tmp.items():
                data[key].append(value)

    with open(args.output, 'w') as f:
        writer = csv.writer(f)
        writer.writerow(data.keys())
        writer.writerows(zip(*data.values()))
